<html>
<head>
	<title>number test</title>
</head>
<body>

	<b>Comic guy:</b>
<div id="testingItem"></div>
<br/>
<b>Decision Tree prediction:</b>
<div id="decisionTreePrediction"></div>
<br/>
<b>Random Forest prediction:</b>
<div id="randomForestPrediction"></div>
<br/>
<b>Decision Tree:</b>
<br/>

<div class="tree" id="displayTree"></div>

	<script src="utils/underscore.js"></script>
	<script src="scripts/jstat.min.js"></script>
	<script src="scripts/decision-tree-min.js"></script>
	<script>
		//cada Real é um grafo estrela.
		// { r : Real = { number:int, (... outros atributos ...) }
		var reals = [];

		//Par ou impar factory
		//essa fabrica cria as chaves pares ou impares
		//a segunda parte trabalha nas sequencias par ou impar
		var factory = function(x)
		{
			if(!_.isNumber(x.n))
				throw new Error('x.n precisa ser um número e é: '+x.n);
			
			var D = as_digits(x);
			x.length = new String(x.n).length;

			x.mean = j$.mean(D);
			x.sum = j$.sum(D);
			x.prod = j$.product(D);
			x.max = j$.max(D);
			x.min = j$.min(D);
			//x.D = D;
			var digit_dimensions = j$.dimensions(D);
			x.dimensions_rows = digit_dimensions.rows;
			x.dimensions_cols =  digit_dimensions.cols;
			x.sumsqrd = j$.sumsqrd(D);
			x.stdev = j$.stdev(D);
			x.meandev = j$.meandev(D);
			x.meddev = j$.meddev(D);
			x.skewness = j$.skewness(D);
			x.coeffvar = j$.coeffvar(D);
			x.sumsqerr = j$.sumsqerr(D);
			x.sumsqrd = j$.sumsqrd(D);

			function init()
			{
				criar_chave();
				set_pares_ou_impares();
			}
			function criar_chave()
			{
				var E = "";

				//concatena par ou impar
				_.each(D,function(d)
				{
					E += (d % 2 == 0) ? 'P' : 'I' ;
				});

				x.chave_par_ou_impar = E;
			}
			function set_pares_ou_impares()
			{
				var Pares = [];
				var Impares = [];

				_.each(D,function(d)
				{
					if(d % 2 == 0)
						Pares.push(d)
					else
						Impares.push(d);
				})
				x.pares = Pares.join('|');
				x.impares = Impares.join('|');
			}
			init();
			reals.push(x)
			console.log(x)
		}
		var as_digits = function(x)
		{
			var Y = new String(x.n).split("");
			_.each(Y,function(v,k)
			{
				Y[k] = parseInt(v);
			})
			return Y;
		}
		_.times(999,function(i)
		{
			var obj = {n:i}
			factory(obj)
		})

// Configuration
var config = {
    trainingSet: reals, 
    categoryAttr: 'prod', 
    ignoredAttributes: ['n']
};

// Building Decision Tree
var decisionTree = new dt.DecisionTree(config);

// Building Random Forest
var numberOfTrees = 3;
var randomForest = new dt.RandomForest(config, numberOfTrees);

// Testing Decision Tree and Random Forest
var comic = {person: 'Comic guy', hairLength: 8, weight: 290, age: 38};

var decisionTreePrediction = decisionTree.predict(comic);
var randomForestPrediction = randomForest.predict(comic);

// Displaying predictions
document.getElementById('testingItem').innerHTML = JSON.stringify(comic, null, 0);
document.getElementById('decisionTreePrediction').innerHTML = JSON.stringify(decisionTreePrediction, null, 0);
document.getElementById('randomForestPrediction').innerHTML = JSON.stringify(randomForestPrediction, null, 0);

// Displaying Decision Tree
document.getElementById('displayTree').innerHTML = treeToHtml(decisionTree.root);


// Recursive (DFS) function for displaying inner structure of decision tree
function treeToHtml(tree) {
    // only leafs containing category
    if (tree.category) {
        return  ['<ul>',
                    '<li>',
                        '<a href="#">',
                            '<b>', tree.category, '</b>',
                        '</a>',
                    '</li>',
                 '</ul>'].join('');
    }
    
    return  ['<ul>',
                '<li>',
                    '<a href="#">',
                        '<b>', tree.attribute, ' ', tree.predicateName, ' ', tree.pivot, ' ?</b>',
                    '</a>',
                    '<ul>',
                        '<li>',
                            '<a href="#">yes</a>',
                            treeToHtml(tree.match),
                        '</li>',
                        '<li>', 
                            '<a href="#">no</a>',
                            treeToHtml(tree.notMatch),
                        '</li>',
                    '</ul>',
                '</li>',
             '</ul>'].join('');
}

	</script>
	<style>
	/*
 Transforming nested lists to pretty tree
 
 <div class="tree">
    <ul>
        <li>
            <ul>
            ...
            </ul>
        </li>
        ...
    </ul>
 </div>
 
Source: http://thecodeplayer.com/walkthrough/css3-family-tree

Some other advices about displaying trees: http://stackoverflow.com/questions/1695115/how-do-i-draw-the-lines-of-a-family-tree-using-html-css
*/

* {
    margin: 0;
    padding: 0;
}

.tree ul {
	padding-top: 20px;
    position: relative;
	
	transition: all 0.5s;
	-webkit-transition: all 0.5s;
	-moz-transition: all 0.5s;
}

.tree li {
    white-space: nowrap;
	float: left;
    text-align: center;
	list-style-type: none;
	position: relative;
	padding: 20px 5px 0 5px;
	
	transition: all 0.5s;
	-webkit-transition: all 0.5s;
	-moz-transition: all 0.5s;
}

/*We will use ::before and ::after to draw the connectors*/

.tree li::before, .tree li::after{
	content: '';
	position: absolute;
    top: 0;
    right: 50%;
	border-top: 1px solid #ccc;
	width: 50%;
    height: 20px;
}
.tree li::after{
	right: auto;
    left: 50%;
	border-left: 1px solid #ccc;
}

/*We need to remove left-right connectors from elements without
 any siblings*/
.tree li:only-child::after, .tree li:only-child::before {
	display: none;
}

/*Remove space from the top of single children*/
.tree li:only-child{
    padding-top: 0;
}

/*Remove left connector from first child and
 right connector from last child*/
.tree li:first-child::before, .tree li:last-child::after{
	border: 0 none;
}
/*Adding back the vertical connector to the last nodes*/
.tree li:last-child::before{
	border-right: 1px solid #ccc;
	border-radius: 0 5px 0 0;
	-webkit-border-radius: 0 5px 0 0;
	-moz-border-radius: 0 5px 0 0;
}
.tree li:first-child::after{
	border-radius: 5px 0 0 0;
	-webkit-border-radius: 5px 0 0 0;
	-moz-border-radius: 5px 0 0 0;
}

/*Time to add downward connectors from parents*/
.tree ul ul::before{
	content: '';
	position: absolute;
    top: 0;
    left: 50%;
	border-left: 1px solid #ccc;
	width: 0;
    height: 20px;
}

.tree li a{
	border: 1px solid #ccc;
	padding: 5px 10px;
	text-decoration: none;
	color: #666;
	font-family: arial, verdana, tahoma;
	font-size: 11px;
	display: inline-block;
	
	border-radius: 5px;
	-webkit-border-radius: 5px;
	-moz-border-radius: 5px;
	
	transition: all 0.5s;
	-webkit-transition: all 0.5s;
	-moz-transition: all 0.5s;
}

/*Time for some hover effects*/
/*We will apply the hover effect the the lineage of the element also*/
.tree li a:hover, .tree li a:hover+ul li a {
	background: #c8e4f8;
    color: #000;
    border: 1px solid #94a0b4;
}
/*Connector styles on hover*/
.tree li a:hover+ul li::after,
.tree li a:hover+ul li::before,
.tree li a:hover+ul::before,
.tree li a:hover+ul ul::before{
	border-color:  #94a0b4;
}

/*Thats all. I hope you enjoyed it.
 Thanks :)*/
	</style>
</body>
</html>